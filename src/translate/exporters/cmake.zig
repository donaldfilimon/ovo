//! CMake Exporter - build.zon -> CMakeLists.txt
//!
//! Generates modern CMake 3.20+ compatible build files:
//! - Target-based configuration (no global settings)
//! - Proper PUBLIC/PRIVATE/INTERFACE scoping
//! - FetchContent for dependencies
//! - Export/install configuration

const std = @import("std");
const Allocator = std.mem.Allocator;
const engine = @import("../engine.zig");
const Project = engine.Project;
const Target = engine.Target;
const TargetKind = engine.TargetKind;
const TranslationOptions = engine.TranslationOptions;

/// Generate CMakeLists.txt from Project
pub fn generate(allocator: Allocator, project: *const Project, output_path: []const u8, options: TranslationOptions) !void {
    const file = try std.fs.cwd().createFile(output_path, .{});
    defer file.close();

    var writer = file.writer();

    // Header comment
    try writer.writeAll("# Generated by ovo translate - do not edit manually\n");
    try writer.writeAll("# https://github.com/ovo-pkg/ovo\n\n");

    // Minimum version
    try writer.print("cmake_minimum_required(VERSION {s})\n\n", .{options.cmake_min_version});

    // Project declaration
    try writer.print("project({s}", .{sanitizeCMakeName(project.name)});

    if (project.version) |ver| {
        try writer.print(" VERSION {s}", .{ver});
    }

    // Detect languages from targets
    var has_c = false;
    var has_cxx = false;

    for (project.targets.items) |target| {
        for (target.sources.items) |src| {
            if (std.mem.endsWith(u8, src, ".c")) has_c = true;
            if (std.mem.endsWith(u8, src, ".cpp") or
                std.mem.endsWith(u8, src, ".cc") or
                std.mem.endsWith(u8, src, ".cxx"))
            {
                has_cxx = true;
            }
        }
    }

    try writer.writeAll(" LANGUAGES");
    if (has_c) try writer.writeAll(" C");
    if (has_cxx) try writer.writeAll(" CXX");
    if (!has_c and !has_cxx) try writer.writeAll(" C CXX");

    if (project.description) |desc| {
        try writer.print("\n    DESCRIPTION \"{s}\"", .{escapeCMakeString(desc)});
    }

    if (project.homepage) |hp| {
        try writer.print("\n    HOMEPAGE_URL \"{s}\"", .{hp});
    }

    try writer.writeAll(")\n\n");

    // C/C++ standards
    try writer.writeAll("# Language standards\n");
    if (has_c) {
        try writer.writeAll("set(CMAKE_C_STANDARD 11)\n");
        try writer.writeAll("set(CMAKE_C_STANDARD_REQUIRED ON)\n");
    }
    if (has_cxx) {
        try writer.writeAll("set(CMAKE_CXX_STANDARD 17)\n");
        try writer.writeAll("set(CMAKE_CXX_STANDARD_REQUIRED ON)\n");
    }
    try writer.writeAll("\n");

    // Dependencies via FetchContent
    if (project.dependencies.items.len > 0) {
        try writer.writeAll("# Dependencies\n");
        try writer.writeAll("include(FetchContent)\n\n");

        for (project.dependencies.items) |dep| {
            try writer.print("# {s}\n", .{dep.name});

            if (dep.url) |url| {
                try writer.print("FetchContent_Declare(\n", .{});
                try writer.print("    {s}\n", .{sanitizeCMakeName(dep.name)});
                try writer.print("    GIT_REPOSITORY {s}\n", .{url});
                if (dep.version) |ver| {
                    try writer.print("    GIT_TAG {s}\n", .{ver});
                }
                try writer.writeAll(")\n");
                try writer.print("FetchContent_MakeAvailable({s})\n\n", .{sanitizeCMakeName(dep.name)});
            } else if (dep.path) |path| {
                try writer.print("add_subdirectory({s})\n\n", .{path});
            } else {
                // Try find_package
                try writer.print("find_package({s}", .{sanitizeCMakeName(dep.name)});
                if (dep.kind == .build) {
                    try writer.writeAll(" REQUIRED");
                }
                try writer.writeAll(")\n\n");
            }
        }
    }

    // Targets
    for (project.targets.items) |target| {
        try generateTarget(allocator, &target, &writer, project.source_root);
    }

    // Install rules
    try writer.writeAll("# Installation rules\n");
    try writer.writeAll("include(GNUInstallDirs)\n\n");

    for (project.targets.items) |target| {
        if (target.kind != .interface) {
            try writer.print("install(TARGETS {s}\n", .{sanitizeCMakeName(target.name)});
            try writer.writeAll("    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}\n");
            try writer.writeAll("    LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}\n");
            try writer.writeAll("    ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}\n");
            try writer.writeAll(")\n\n");
        }
    }
}

fn generateTarget(_: Allocator, target: *const Target, writer: anytype, source_root: []const u8) !void {
    const cmake_name = sanitizeCMakeName(target.name);

    // Target declaration
    switch (target.kind) {
        .executable => {
            try writer.print("add_executable({s}", .{cmake_name});
        },
        .static_library => {
            try writer.print("add_library({s} STATIC", .{cmake_name});
        },
        .shared_library => {
            try writer.print("add_library({s} SHARED", .{cmake_name});
        },
        .interface, .header_only => {
            try writer.print("add_library({s} INTERFACE", .{cmake_name});
        },
        .object_library => {
            try writer.print("add_library({s} OBJECT", .{cmake_name});
        },
        .custom => {
            try writer.print("add_custom_target({s}", .{cmake_name});
        },
    }

    // Source files
    if (target.kind != .interface and target.kind != .header_only) {
        try writer.writeAll("\n");
        for (target.sources.items) |src| {
            const rel_path = makeRelativePath(src, source_root);
            try writer.print("    {s}\n", .{rel_path});
        }
    }

    try writer.writeAll(")\n\n");

    // Compile definitions
    if (target.flags.defines.items.len > 0) {
        const visibility = if (target.kind == .interface or target.kind == .header_only) "INTERFACE" else "PRIVATE";
        try writer.print("target_compile_definitions({s} {s}\n", .{ cmake_name, visibility });
        for (target.flags.defines.items) |def| {
            try writer.print("    {s}\n", .{def});
        }
        try writer.writeAll(")\n\n");
    }

    // Include directories
    if (target.flags.include_paths.items.len > 0 or target.flags.system_include_paths.items.len > 0) {
        try writer.print("target_include_directories({s}\n", .{cmake_name});

        const visibility = if (target.kind == .interface or target.kind == .header_only) "INTERFACE" else "PUBLIC";

        for (target.flags.include_paths.items) |inc| {
            const rel_path = makeRelativePath(inc, source_root);
            try writer.print("    {s} {s}\n", .{ visibility, rel_path });
        }

        for (target.flags.system_include_paths.items) |inc| {
            const rel_path = makeRelativePath(inc, source_root);
            try writer.print("    SYSTEM {s} {s}\n", .{ visibility, rel_path });
        }

        try writer.writeAll(")\n\n");
    }

    // Link libraries
    if (target.flags.link_libraries.items.len > 0 or target.dependencies.items.len > 0) {
        const visibility = if (target.kind == .interface or target.kind == .header_only) "INTERFACE" else "PRIVATE";
        try writer.print("target_link_libraries({s} {s}\n", .{ cmake_name, visibility });

        for (target.flags.link_libraries.items) |lib| {
            try writer.print("    {s}\n", .{lib});
        }

        for (target.dependencies.items) |dep| {
            try writer.print("    {s}\n", .{sanitizeCMakeName(dep)});
        }

        try writer.writeAll(")\n\n");
    }

    // Frameworks (macOS)
    if (target.flags.frameworks.items.len > 0) {
        try writer.print("if(APPLE)\n", .{});
        try writer.print("    target_link_libraries({s} PRIVATE\n", .{cmake_name});
        for (target.flags.frameworks.items) |fw| {
            try writer.print("        \"-framework {s}\"\n", .{fw});
        }
        try writer.writeAll("    )\n");
        try writer.writeAll("endif()\n\n");
    }

    // Compile options
    if (target.flags.compile_flags.items.len > 0) {
        const visibility = if (target.kind == .interface or target.kind == .header_only) "INTERFACE" else "PRIVATE";
        try writer.print("target_compile_options({s} {s}\n", .{ cmake_name, visibility });
        for (target.flags.compile_flags.items) |flag| {
            try writer.print("    {s}\n", .{flag});
        }
        try writer.writeAll(")\n\n");
    }

    // Link options
    if (target.flags.link_flags.items.len > 0) {
        try writer.print("target_link_options({s} PRIVATE\n", .{cmake_name});
        for (target.flags.link_flags.items) |flag| {
            try writer.print("    {s}\n", .{flag});
        }
        try writer.writeAll(")\n\n");
    }

    // Output name
    if (target.output_name) |out_name| {
        try writer.print("set_target_properties({s} PROPERTIES\n", .{cmake_name});
        try writer.print("    OUTPUT_NAME \"{s}\"\n", .{out_name});
        try writer.writeAll(")\n\n");
    }
}

fn sanitizeCMakeName(name: []const u8) []const u8 {
    // CMake names should be alphanumeric with underscores
    // For now, just return as-is; a real implementation would sanitize
    return name;
}

fn escapeCMakeString(s: []const u8) []const u8 {
    // Escape special characters in CMake strings
    // For now, just return as-is; a real implementation would escape
    return s;
}

fn makeRelativePath(path: []const u8, base: []const u8) []const u8 {
    // Make path relative to base
    if (std.mem.startsWith(u8, path, base)) {
        var rel = path[base.len..];
        if (rel.len > 0 and rel[0] == '/') {
            rel = rel[1..];
        }
        if (rel.len == 0) return ".";
        return rel;
    }
    return path;
}

// Tests
test "sanitizeCMakeName" {
    try std.testing.expectEqualStrings("mylib", sanitizeCMakeName("mylib"));
}

test "makeRelativePath" {
    try std.testing.expectEqualStrings("src/main.c", makeRelativePath("/project/src/main.c", "/project"));
    try std.testing.expectEqualStrings("/other/path", makeRelativePath("/other/path", "/project"));
}
