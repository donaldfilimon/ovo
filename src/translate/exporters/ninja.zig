//! Ninja Exporter - build.zon -> build.ninja
//!
//! Generates Ninja build files:
//! - Minimal, fast build system
//! - Explicit dependency tracking
//! - Parallel execution friendly
//! - Used by many other build systems as backend

const std = @import("std");
const Allocator = std.mem.Allocator;
const engine = @import("../engine.zig");
const Project = engine.Project;
const Target = engine.Target;
const TargetKind = engine.TargetKind;
const TranslationOptions = engine.TranslationOptions;

/// Generate build.ninja from Project
pub fn generate(allocator: Allocator, project: *const Project, output_path: []const u8, options: TranslationOptions) !void {
    _ = options;

    const file = try std.fs.cwd().createFile(output_path, .{});
    defer file.close();

    var writer = file.writer();

    // Header comment
    try writer.writeAll("# Generated by ovo translate\n");
    try writer.writeAll("# https://github.com/ovo-pkg/ovo\n\n");

    // Ninja required version
    try writer.writeAll("ninja_required_version = 1.5\n\n");

    // Build directory
    try writer.writeAll("builddir = build\n\n");

    // Detect compilers and set up rules
    var has_c = false;
    var has_cxx = false;

    for (project.targets.items) |target| {
        for (target.sources.items) |src| {
            if (std.mem.endsWith(u8, src, ".c")) has_c = true;
            if (std.mem.endsWith(u8, src, ".cpp") or
                std.mem.endsWith(u8, src, ".cc") or
                std.mem.endsWith(u8, src, ".cxx"))
            {
                has_cxx = true;
            }
        }
    }

    // Variables
    if (has_c or has_cxx) {
        try writer.writeAll("# Compilers\n");
        if (has_c) {
            try writer.writeAll("cc = cc\n");
        }
        if (has_cxx) {
            try writer.writeAll("cxx = c++\n");
        }
        try writer.writeAll("ar = ar\n");
        try writer.writeAll("\n");
    }

    // Common flags
    try writer.writeAll("# Flags\n");
    try writer.writeAll("cflags = -Wall -Wextra\n");
    try writer.writeAll("cxxflags = -Wall -Wextra -std=c++17\n");
    try writer.writeAll("ldflags =\n");
    try writer.writeAll("\n");

    // Rules
    try writer.writeAll("# Rules\n");

    if (has_c) {
        try writer.writeAll(
            \\rule cc
            \\  command = $cc -MMD -MF $out.d $cflags $defines $includes -c $in -o $out
            \\  description = CC $out
            \\  depfile = $out.d
            \\  deps = gcc
            \\
            \\
        );
    }

    if (has_cxx) {
        try writer.writeAll(
            \\rule cxx
            \\  command = $cxx -MMD -MF $out.d $cxxflags $defines $includes -c $in -o $out
            \\  description = CXX $out
            \\  depfile = $out.d
            \\  deps = gcc
            \\
            \\
        );
    }

    try writer.writeAll(
        \\rule link
        \\  command = $cxx $ldflags -o $out $in $libs
        \\  description = LINK $out
        \\
        \\rule link_c
        \\  command = $cc $ldflags -o $out $in $libs
        \\  description = LINK $out
        \\
        \\rule ar
        \\  command = rm -f $out && $ar crs $out $in
        \\  description = AR $out
        \\
        \\rule shared
        \\  command = $cxx -shared $ldflags -o $out $in $libs
        \\  description = SHARED $out
        \\
        \\
    );

    // Generate build statements for each target
    for (project.targets.items) |target| {
        try generateTargetBuild(allocator, &target, &writer, project.source_root);
    }

    // Default target (first executable or first target)
    try writer.writeAll("\n# Default target\n");
    var default_target: ?[]const u8 = null;

    for (project.targets.items) |target| {
        if (target.kind == .executable) {
            default_target = target.name;
            break;
        }
    }

    if (default_target == null and project.targets.items.len > 0) {
        default_target = project.targets.items[0].name;
    }

    if (default_target) |dt| {
        try writer.print("default {s}\n", .{dt});
    }

    // All target
    if (project.targets.items.len > 1) {
        try writer.writeAll("\nbuild all: phony");
        for (project.targets.items) |target| {
            try writer.print(" {s}", .{outputName(&target)});
        }
        try writer.writeAll("\n");
    }

    // Clean target
    try writer.writeAll("\n# Clean build\n");
    try writer.writeAll("rule clean_cmd\n");
    try writer.writeAll("  command = rm -rf $builddir\n");
    try writer.writeAll("  description = CLEAN\n\n");
    try writer.writeAll("build clean: clean_cmd\n");
}

fn generateTargetBuild(allocator: Allocator, target: *const Target, writer: anytype, source_root: []const u8) !void {
    try writer.print("\n# Target: {s}\n", .{target.name});

    // Build defines and includes strings
    var defines_buf = std.ArrayList(u8).init(allocator);
    defer defines_buf.deinit();

    for (target.flags.defines.items) |def| {
        try defines_buf.appendSlice("-D");
        try defines_buf.appendSlice(def);
        try defines_buf.append(' ');
    }

    var includes_buf = std.ArrayList(u8).init(allocator);
    defer includes_buf.deinit();

    for (target.flags.include_paths.items) |inc| {
        try includes_buf.appendSlice("-I");
        const rel = makeRelativePath(inc, source_root);
        try includes_buf.appendSlice(rel);
        try includes_buf.append(' ');
    }

    for (target.flags.system_include_paths.items) |inc| {
        try includes_buf.appendSlice("-isystem ");
        const rel = makeRelativePath(inc, source_root);
        try includes_buf.appendSlice(rel);
        try includes_buf.append(' ');
    }

    // Track object files
    var objects = std.ArrayList([]const u8).init(allocator);
    defer objects.deinit();

    // Compile each source file
    for (target.sources.items) |src| {
        const rel_src = makeRelativePath(src, source_root);
        const basename = std.fs.path.basename(src);
        const stem = std.fs.path.stem(basename);

        const obj_path = try std.fmt.allocPrint(allocator, "$builddir/{s}/{s}.o", .{ target.name, stem });
        try objects.append(obj_path);

        // Determine compiler rule
        const rule: []const u8 = if (std.mem.endsWith(u8, src, ".c")) "cc" else "cxx";

        try writer.print("build {s}: {s} {s}\n", .{ obj_path, rule, rel_src });

        if (defines_buf.items.len > 0) {
            try writer.print("  defines = {s}\n", .{defines_buf.items});
        }
        if (includes_buf.items.len > 0) {
            try writer.print("  includes = {s}\n", .{includes_buf.items});
        }

        // Per-file compile flags
        if (target.flags.compile_flags.items.len > 0) {
            try writer.writeAll("  cflags = $cflags");
            for (target.flags.compile_flags.items) |flag| {
                try writer.print(" {s}", .{flag});
            }
            try writer.writeAll("\n");
        }
    }

    // Link target
    const out_name = outputName(target);
    const link_rule: []const u8 = switch (target.kind) {
        .executable => if (hasOnlyCSources(target)) "link_c" else "link",
        .static_library => "ar",
        .shared_library => "shared",
        else => "link",
    };

    try writer.print("\nbuild {s}: {s}", .{ out_name, link_rule });

    // Object files
    for (objects.items) |obj| {
        try writer.print(" {s}", .{obj});
    }

    // Dependencies (other targets)
    for (target.dependencies.items) |dep| {
        try writer.print(" {s}", .{dep});
    }

    try writer.writeAll("\n");

    // Link flags
    if (target.flags.link_flags.items.len > 0) {
        try writer.writeAll("  ldflags = $ldflags");
        for (target.flags.link_flags.items) |flag| {
            try writer.print(" {s}", .{flag});
        }
        try writer.writeAll("\n");
    }

    // Link libraries
    if (target.flags.link_libraries.items.len > 0 or target.flags.frameworks.items.len > 0) {
        try writer.writeAll("  libs =");
        for (target.flags.link_libraries.items) |lib| {
            if (std.mem.startsWith(u8, lib, "-")) {
                try writer.print(" {s}", .{lib});
            } else {
                try writer.print(" -l{s}", .{lib});
            }
        }
        for (target.flags.frameworks.items) |fw| {
            try writer.print(" -framework {s}", .{fw});
        }
        try writer.writeAll("\n");
    }
}

fn outputName(target: *const Target) []const u8 {
    if (target.output_name) |name| return name;

    return switch (target.kind) {
        .executable => target.name,
        .static_library => target.name, // Would be lib{name}.a in a real impl
        .shared_library => target.name, // Would be lib{name}.so/.dylib
        else => target.name,
    };
}

fn hasOnlyCSources(target: *const Target) bool {
    for (target.sources.items) |src| {
        if (!std.mem.endsWith(u8, src, ".c")) {
            return false;
        }
    }
    return true;
}

fn makeRelativePath(path: []const u8, base: []const u8) []const u8 {
    if (std.mem.startsWith(u8, path, base)) {
        var rel = path[base.len..];
        if (rel.len > 0 and rel[0] == '/') {
            rel = rel[1..];
        }
        if (rel.len == 0) return ".";
        return rel;
    }
    return path;
}

// Tests
test "outputName" {
    const allocator = std.testing.allocator;
    var target = Target.init(allocator, "myapp", .executable);
    defer target.deinit();

    try std.testing.expectEqualStrings("myapp", outputName(&target));
}

test "hasOnlyCSources" {
    const allocator = std.testing.allocator;

    var target1 = Target.init(allocator, "test", .executable);
    defer target1.deinit();
    try target1.sources.append("main.c");
    try target1.sources.append("utils.c");
    try std.testing.expect(hasOnlyCSources(&target1));

    var target2 = Target.init(allocator, "test", .executable);
    defer target2.deinit();
    try target2.sources.append("main.cpp");
    try std.testing.expect(!hasOnlyCSources(&target2));
}
