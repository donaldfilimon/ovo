const std = @import("std");
const Context = @import("context.zig").Context;
const scaffold = @import("scaffold.zig");
const core = @import("../core/mod.zig");
const project_mod = @import("../core/project.zig");
const build = @import("../build/mod.zig");
const package = @import("../package/mod.zig");
const translate = @import("../translate/mod.zig");

pub fn handleNew(ctx: *Context, command_args: []const []const u8) !u8 {
    if (command_args.len == 0) {
        try ctx.printErr("error: missing project name\n", .{});
        return 2;
    }
    const name = command_args[0];
    try scaffold.createProjectSkeleton(ctx.allocator, name, name);
    try core.fs.writeFile(
        try std.fmt.allocPrint(ctx.allocator, "{s}/README.md", .{name}),
        "Generated by OVO\n",
    );
    try ctx.print("new: created project '{s}'\n", .{name});
    return 0;
}

pub fn handleInit(ctx: *Context, _: []const []const u8) !u8 {
    const cwd_name = projectNameFromCwd(ctx.allocator);
    try scaffold.createProjectSkeleton(ctx.allocator, ".", cwd_name);
    try ctx.print("init: wrote build.zon and starter C++ layout for '{s}'\n", .{cwd_name});
    return 0;
}

pub fn handleBuild(ctx: *Context, command_args: []const []const u8, _: []const []const u8) !u8 {
    const result = try build.orchestrator.buildProject(ctx.allocator, .{
        .target_name = if (command_args.len > 0) command_args[0] else null,
        .optimize_override = ctx.profile,
    });
    try ctx.print("build: project={s}\n", .{result.project_name});
    for (result.artifacts) |artifact| {
        try ctx.print("  built {s} -> {s}\n", .{ artifact.name, artifact.path });
    }
    return 0;
}

pub fn handleRun(ctx: *Context, command_args: []const []const u8, passthrough_args: []const []const u8) !u8 {
    var requested_target = if (command_args.len > 0) command_args[0] else null;
    if (requested_target == null) {
        const project = try build.orchestrator.loadProject(ctx.allocator);
        const target = build.orchestrator.defaultRunnableTarget(project) orelse {
            try ctx.printErr("error: no executable or test target available\n", .{});
            return 2;
        };
        requested_target = target.name;
    }

    const result = try build.orchestrator.buildProject(ctx.allocator, .{
        .target_name = requested_target,
        .optimize_override = ctx.profile,
    });
    const artifact = build.orchestrator.findRunnableArtifact(result, requested_target) orelse {
        try ctx.printErr("error: no runnable executable target found\n", .{});
        return 2;
    };

    var argv: std.ArrayList([]const u8) = .empty;
    try argv.append(ctx.allocator, artifact.path);
    for (passthrough_args) |arg| try argv.append(ctx.allocator, arg);
    const code = try core.exec.runInherit(ctx.allocator, argv.items);
    return code;
}

pub fn handleTest(ctx: *Context, command_args: []const []const u8, _: []const []const u8) !u8 {
    const pattern = if (command_args.len > 0) command_args[0] else null;
    const result = try build.orchestrator.buildProject(ctx.allocator, .{
        .target_pattern = pattern,
        .optimize_override = ctx.profile,
        .test_only = true,
    });

    for (result.artifacts) |artifact| {
        var argv: std.ArrayList([]const u8) = .empty;
        try argv.append(ctx.allocator, artifact.path);
        const code = try core.exec.runInherit(ctx.allocator, argv.items);
        if (code != 0) return code;
    }
    try ctx.print("test: executed {d} test target(s)\n", .{result.artifacts.len});
    return 0;
}

pub fn handleClean(ctx: *Context, _: []const []const u8) !u8 {
    try core.fs.removeTreeIfExists(".ovo");
    try core.fs.deleteFileIfExists("ovo.lock.zon");
    try ctx.print("clean: removed .ovo and transient lock artifacts\n", .{});
    return 0;
}

pub fn handleInstall(ctx: *Context, _: []const []const u8) !u8 {
    const result = try build.orchestrator.buildProject(ctx.allocator, .{
        .optimize_override = ctx.profile,
    });
    try core.fs.ensureDir(".ovo/install/bin");
    try core.fs.ensureDir(".ovo/install/lib");

    for (result.artifacts) |artifact| {
        const file_name = std.fs.path.basename(artifact.path);
        const install_path = switch (artifact.kind) {
            .executable, .test_target => try std.fmt.allocPrint(ctx.allocator, ".ovo/install/bin/{s}", .{file_name}),
            .library_static, .library_shared => try std.fmt.allocPrint(ctx.allocator, ".ovo/install/lib/{s}", .{file_name}),
        };
        try core.fs.copyFile(artifact.path, install_path);
        try ctx.print("install: {s}\n", .{install_path});
    }
    return 0;
}

pub fn handleAdd(ctx: *Context, command_args: []const []const u8) !u8 {
    if (command_args.len == 0) {
        try ctx.printErr("error: missing package name\n", .{});
        return 2;
    }
    var manager = package.manager.PackageManager.init(ctx.allocator);
    const version = if (command_args.len > 1) command_args[1] else null;
    try manager.add(command_args[0], version);
    try ctx.print("add: {s}\n", .{command_args[0]});
    return 0;
}

pub fn handleRemove(ctx: *Context, command_args: []const []const u8) !u8 {
    if (command_args.len == 0) {
        try ctx.printErr("error: missing package name\n", .{});
        return 2;
    }
    var manager = package.manager.PackageManager.init(ctx.allocator);
    try manager.remove(command_args[0]);
    try ctx.print("remove: {s}\n", .{command_args[0]});
    return 0;
}

pub fn handleFetch(ctx: *Context, _: []const []const u8) !u8 {
    const project = try build.orchestrator.loadProject(ctx.allocator);
    var manager = package.manager.PackageManager.init(ctx.allocator);
    try manager.fetch();
    try ctx.print("fetch: dependency cache refreshed ({d} deps)\n", .{project.dependencies.len});
    return 0;
}

pub fn handleUpdate(ctx: *Context, command_args: []const []const u8) !u8 {
    var manager = package.manager.PackageManager.init(ctx.allocator);
    const dep = if (command_args.len > 0) command_args[0] else null;
    try manager.update(dep);
    if (dep) |name| {
        try ctx.print("update: dependency {s} updated\n", .{name});
    } else {
        try ctx.print("update: dependencies updated\n", .{});
    }
    return 0;
}

pub fn handleLock(ctx: *Context, _: []const []const u8) !u8 {
    var manager = package.manager.PackageManager.init(ctx.allocator);
    try manager.lock();
    try ctx.print("lock: wrote ovo.lock.zon\n", .{});
    return 0;
}

pub fn handleDeps(ctx: *Context, _: []const []const u8) !u8 {
    var manager = package.manager.PackageManager.init(ctx.allocator);
    const summary = try manager.dependencySummary();
    try ctx.print("{s}\n", .{summary});
    return 0;
}

pub fn handleDoc(ctx: *Context, _: []const []const u8) !u8 {
    const project = try build.orchestrator.loadProject(ctx.allocator);
    try core.fs.ensureDir("docs");
    var output: std.ArrayList(u8) = .empty;

    try output.print(ctx.allocator, "# {s}\n\n", .{project.name});
    try output.print(ctx.allocator, "- Version: `{s}`\n", .{project.version});
    try output.print(ctx.allocator, "- License: `{s}`\n", .{project.license orelse "n/a"});
    try output.print(ctx.allocator, "- Targets: `{d}`\n", .{project.targets.len});
    try output.print(ctx.allocator, "- Dependencies: `{d}`\n", .{project.dependencies.len});
    try output.appendSlice(ctx.allocator, "\n## Targets\n");
    for (project.targets) |target| {
        try output.print(ctx.allocator, "- `{s}` (`{s}`)\n", .{ target.name, project_mod.targetTypeLabel(target.kind) });
    }

    try core.fs.writeFile("docs/project-reference.md", output.items);
    try ctx.print("doc: wrote docs/project-reference.md\n", .{});
    return 0;
}

pub fn handleDoctor(ctx: *Context, _: []const []const u8) !u8 {
    const required_version_raw = core.fs.readFileAlloc(ctx.allocator, ".zigversion") catch null;
    const required_version: []const u8 = if (required_version_raw) |bytes|
        std.mem.trim(u8, bytes, " \t\r\n")
    else
        "0.16.0";
    try ctx.print("doctor: required_zig={s}\n", .{required_version});
    const zig_version_code = core.exec.runInherit(ctx.allocator, &.{ "zig", "version" }) catch 1;
    if (zig_version_code != 0) {
        try ctx.printErr("doctor: unable to run `zig version`\n", .{});
    }

    const tools = [_][]const u8{
        "zig",
        "clang++",
        "g++",
        "cmake",
        "ninja",
        "clang-format",
        "clang-tidy",
        "doxygen",
        "clang-doc",
    };
    var missing: usize = 0;
    for (tools) |tool| {
        const available = core.exec.commandExists(ctx.allocator, tool);
        try ctx.print("doctor: {s} {s}\n", .{ tool, if (available) "ok" else "missing" });
        if (!available) missing += 1;
    }
    return if (missing == 0) 0 else 1;
}

pub fn handleFmt(ctx: *Context, _: []const []const u8) !u8 {
    if (!core.exec.commandExists(ctx.allocator, "clang-format")) {
        try ctx.printErr("error: clang-format not found in PATH\n", .{});
        return 2;
    }
    const project = try build.orchestrator.loadProject(ctx.allocator);
    var any = false;
    for (project.targets) |target| {
        for (target.sources) |pattern| {
            const sources = try build.orchestrator.resolveSourcePattern(ctx.allocator, pattern);
            for (sources) |source| {
                const code = try core.exec.runInherit(ctx.allocator, &.{ "clang-format", "-i", source });
                if (code != 0) return code;
                any = true;
            }
        }
    }
    if (!any) {
        try ctx.print("fmt: no source files found\n", .{});
    } else {
        try ctx.print("fmt: formatted project sources\n", .{});
    }
    return 0;
}

pub fn handleLint(ctx: *Context, _: []const []const u8) !u8 {
    if (!core.exec.commandExists(ctx.allocator, "clang-tidy")) {
        try ctx.printErr("error: clang-tidy not found in PATH\n", .{});
        return 2;
    }
    const project = try build.orchestrator.loadProject(ctx.allocator);
    var any = false;
    for (project.targets) |target| {
        for (target.sources) |pattern| {
            const sources = try build.orchestrator.resolveSourcePattern(ctx.allocator, pattern);
            for (sources) |source| {
                const code = try core.exec.runInherit(ctx.allocator, &.{ "clang-tidy", source, "--", "-std=c++20" });
                if (code != 0) return code;
                any = true;
            }
        }
    }
    if (!any) {
        try ctx.print("lint: no source files found\n", .{});
    } else {
        try ctx.print("lint: linted project sources\n", .{});
    }
    return 0;
}

pub fn handleInfo(ctx: *Context, _: []const []const u8) !u8 {
    const project = try build.orchestrator.loadProject(ctx.allocator);
    try ctx.print("project: {s}\n", .{project.name});
    try ctx.print("version: {s}\n", .{project.version});
    try ctx.print("license: {s}\n", .{project.license orelse "n/a"});
    try ctx.print("schema: {s}\n", .{project.ovo_schema});
    try ctx.print("targets: {d}\n", .{project.targets.len});
    try ctx.print("dependencies: {d}\n", .{project.dependencies.len});
    try ctx.print("backend: {s}\n", .{project.defaults.backend});
    try ctx.print("optimize: {s}\n", .{project.defaults.optimize});
    try ctx.print("output_dir: {s}\n", .{project.defaults.output_dir});
    if (project.targets.len > 0) {
        try ctx.print("target_list:\n", .{});
        for (project.targets) |target| {
            try ctx.print("  - {s} ({s})\n", .{ target.name, project_mod.targetTypeLabel(target.kind) });
        }
    }
    if (project.dependencies.len > 0) {
        try ctx.print("dependency_list:\n", .{});
        for (project.dependencies) |dep| {
            try ctx.print("  - {s}@{s}\n", .{ dep.name, dep.version });
        }
    }
    return 0;
}

pub fn handleImport(ctx: *Context, command_args: []const []const u8) !u8 {
    if (command_args.len == 0) {
        try ctx.printErr("error: missing import format\n", .{});
        return 2;
    }
    const format = translate.importer.parseImportFormat(command_args[0]) orelse {
        try ctx.printErr("error: unsupported import format '{s}'\n", .{command_args[0]});
        return 2;
    };
    const source_path = if (command_args.len > 1) command_args[1] else ".";
    const imported = try translate.importer.importIntoBuildZon(ctx.allocator, format, source_path);
    if (core.fs.fileExists("build.zon")) {
        try core.fs.copyFile("build.zon", "build.zon.bak");
    }
    try translate.importer.writeImportedProject(ctx.allocator, imported);
    try ctx.print("import: converted {s} -> build.zon\n", .{translate.importer.label(format)});
    return 0;
}

pub fn handleExport(ctx: *Context, command_args: []const []const u8) !u8 {
    if (command_args.len == 0) {
        try ctx.printErr("error: missing export format\n", .{});
        return 2;
    }
    const format = translate.exporter.parseExportFormat(command_args[0]) orelse {
        try ctx.printErr("error: unsupported export format '{s}'\n", .{command_args[0]});
        return 2;
    };
    const project = try build.orchestrator.loadProject(ctx.allocator);
    const content = try translate.exporter.exportProject(ctx.allocator, project, format);
    const output_path = if (command_args.len > 1)
        command_args[1]
    else
        try translate.exporter.defaultPathForFormat(ctx.allocator, project, format);
    try translate.exporter.writeExport(output_path, content);
    try ctx.print("export: wrote {s}\n", .{output_path});
    return 0;
}

fn projectNameFromCwd(allocator: std.mem.Allocator) []const u8 {
    const cwd = core.fs.currentPathAlloc(allocator) catch return "app";
    return std.fs.path.basename(cwd);
}
