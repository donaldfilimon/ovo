//! ovo lock command
//!
//! Generate or update the lock file from build.zon.
//! Usage: ovo lock

const std = @import("std");
const commands = @import("commands.zig");
const manifest = @import("manifest.zig");
const zon = @import("zon");

const zon_parser = zon.parser;
const zon_schema = zon.schema;

const Context = commands.Context;
const TermWriter = commands.TermWriter;

/// Print help for lock command
fn printHelp(writer: *TermWriter) !void {
    try writer.bold("ovo lock", .{});
    try writer.print(" - Generate lock file from build.zon\n\n", .{});

    try writer.bold("USAGE:\n", .{});
    try writer.print("    ovo lock [options]\n\n", .{});

    try writer.bold("OPTIONS:\n", .{});
    try writer.print("    -h, --help    Show this help message\n", .{});

    try writer.print("\n", .{});
    try writer.bold("EXAMPLES:\n", .{});
    try writer.dim("    ovo lock       # Generate ovo.lock from dependencies\n", .{});
    try writer.dim("    ovo fetch      # Fetch also generates/updates lock file\n", .{});
}

/// Format a single dependency entry for the lock file.
fn formatDependencyLine(allocator: std.mem.Allocator, dep: zon_schema.Dependency) ![]u8 {
    switch (dep.source) {
        .git => |git| {
            if (git.tag) |tag| {
                return std.fmt.allocPrint(
                    allocator,
                    "{s} = {{ source = \"git\", url = \"{s}\", tag = \"{s}\" }}",
                    .{ dep.name, git.url, tag },
                );
            } else if (git.branch) |branch| {
                return std.fmt.allocPrint(
                    allocator,
                    "{s} = {{ source = \"git\", url = \"{s}\", branch = \"{s}\" }}",
                    .{ dep.name, git.url, branch },
                );
            } else if (git.commit) |commit| {
                return std.fmt.allocPrint(
                    allocator,
                    "{s} = {{ source = \"git\", url = \"{s}\", commit = \"{s}\" }}",
                    .{ dep.name, git.url, commit },
                );
            }
            return std.fmt.allocPrint(
                allocator,
                "{s} = {{ source = \"git\", url = \"{s}\" }}",
                .{ dep.name, git.url },
            );
        },
        .url => |url| {
            if (url.hash) |hash| {
                return std.fmt.allocPrint(
                    allocator,
                    "{s} = {{ source = \"url\", location = \"{s}\", hash = \"{s}\" }}",
                    .{ dep.name, url.location, hash },
                );
            }
            return std.fmt.allocPrint(
                allocator,
                "{s} = {{ source = \"url\", location = \"{s}\" }}",
                .{ dep.name, url.location },
            );
        },
        .path => |path| {
            return std.fmt.allocPrint(
                allocator,
                "{s} = {{ source = \"path\", path = \"{s}\" }}",
                .{ dep.name, path },
            );
        },
        .vcpkg => |vcpkg| {
            if (vcpkg.version) |version| {
                return std.fmt.allocPrint(
                    allocator,
                    "{s} = {{ source = \"vcpkg\", name = \"{s}\", version = \"{s}\" }}",
                    .{ dep.name, vcpkg.name, version },
                );
            }
            return std.fmt.allocPrint(
                allocator,
                "{s} = {{ source = \"vcpkg\", name = \"{s}\" }}",
                .{ dep.name, vcpkg.name },
            );
        },
        .conan => |conan| {
            return std.fmt.allocPrint(
                allocator,
                "{s} = {{ source = \"conan\", name = \"{s}\", version = \"{s}\" }}",
                .{ dep.name, conan.name, conan.version },
            );
        },
        .system => |sys| {
            return std.fmt.allocPrint(
                allocator,
                "{s} = {{ source = \"system\", name = \"{s}\" }}",
                .{ dep.name, sys.name },
            );
        },
    }
}

/// Build the complete lock file content from a parsed project.
fn buildLockFileContent(allocator: std.mem.Allocator, deps: []zon_schema.Dependency) ![]u8 {
    var buf: std.ArrayList(u8) = .{};
    errdefer buf.deinit(allocator);

    try buf.appendSlice(allocator, "# ovo.lock\n");
    try buf.appendSlice(allocator, "# Auto-generated by: ovo lock\n");
    try buf.appendSlice(allocator, "# Do not edit manually\n");
    try buf.appendSlice(allocator, "\n[dependencies]\n");

    for (deps) |dep| {
        const line = try formatDependencyLine(allocator, dep);
        defer allocator.free(line);
        try buf.appendSlice(allocator, line);
        try buf.appendSlice(allocator, "\n");
    }

    return buf.toOwnedSlice(allocator);
}

/// Execute the lock command
pub fn execute(ctx: *Context, args: []const []const u8) !u8 {
    if (commands.hasHelpFlag(args)) {
        try printHelp(ctx.stdout);
        return 0;
    }

    const manifest_exists = blk: {
        ctx.cwd.access(manifest.manifest_filename, .{}) catch break :blk false;
        break :blk true;
    };

    if (!manifest_exists) {
        try ctx.stderr.err("error: ", .{});
        try ctx.stderr.print("no {s} found in current directory\n", .{manifest.manifest_filename});
        return 1;
    }

    // Parse build.zon
    var project = zon_parser.parseFile(ctx.allocator, manifest.manifest_filename) catch |err| {
        try ctx.stderr.err("error: ", .{});
        try ctx.stderr.print("failed to parse {s}: {}\n", .{ manifest.manifest_filename, err });
        return 1;
    };
    defer project.deinit(ctx.allocator);

    // Check for dependencies
    const deps = project.dependencies orelse {
        try ctx.stdout.info("Lock", .{});
        try ctx.stdout.print(" No dependencies to lock.\n", .{});
        return 0;
    };

    if (deps.len == 0) {
        try ctx.stdout.info("Lock", .{});
        try ctx.stdout.print(" No dependencies to lock.\n", .{});
        return 0;
    }

    // Build lock file content
    const content = try buildLockFileContent(ctx.allocator, deps);
    defer ctx.allocator.free(content);

    // Write to lock file
    const lock_file = ctx.cwd.createFile(manifest.lock_filename, .{}) catch |err| {
        try ctx.stderr.err("error: ", .{});
        try ctx.stderr.print("failed to create {s}: {}\n", .{ manifest.lock_filename, err });
        return 1;
    };
    defer lock_file.close();

    lock_file.writeAll(content) catch |err| {
        try ctx.stderr.err("error: ", .{});
        try ctx.stderr.print("failed to write {s}: {}\n", .{ manifest.lock_filename, err });
        return 1;
    };

    try ctx.stdout.success("Lock", .{});
    try ctx.stdout.print(" file written to {s} ({d} dependencies)\n", .{ manifest.lock_filename, deps.len });
    return 0;
}
